[[network]]
Networking
----------

Description of Transports
~~~~~~~~~~~~~~~~~~~~~~~~~

A Rai MS transports function is to join all of the peers connected through a
node together in one virtual overlay network that provides basic pub/sub
multicast.

A transport has two primary roles, the routing of messages between peers and
the managing of protocol dependent subscription management and message framing.
The internal transports (PGM, TCP Mesh) all use the internal protocol semantics
for messaging.  The external bridged transports (RV, NATS, Redis) have
protocols with similarities, but they have unique behaviors that make them more
complicated that the internal transports.

The design of the internal transports allow them to be used by any of the
external transports, so RV can use a TCP mesh or PGM multicast or some of
combination of them interconnected.  Similar for NATS and Redis, they can also
use PGM multicast as well as a TCP mesh.  The routing of messages between peers
is agnostic to the type of protocol that the endpoint clients are using.  It is
possible to use the Rai MS protocol directly as well.  The `ms_server` console
contains the ability to publish, subscribe without using an external client.
The `telnet` transport uses the console protocol.

There are two sides to transport configuration, the listener and the connector.
An external transport does not (yet) support the connector side, only the
listener side.  The internal transports support both.

The config file format is a JSON or YAML with a record that has these fields:

----
  tport: <name>
  type: <pgm | mesh | tcp | rv | nats | redis | telnet>
  route:
    listen: <address>
    connect: <address>
    port: <number>
    <parm>: <value>
----

The `name` identifies the transport so that it can be referenced for starting
and stopping in the console and the command line.  It is also sent to other
peers so that it can be read in log files and diagnostic output.  It has no
protocol implications, a misspelling won't cause it to stop working, it will
just be confusing for the operator.

Open PGM
~~~~~~~~

PGM is a multicast protocol, which layers reliability on the native UDP
multicast.  The parameters for it declare the amount of memory used for
buffering data and control the timers when retransmitting is necessary.

The type of PGM used is UDP encapsulated using the port specified.  The address
specification has a network, a send address, and multiple receive addresses,
formatted as `network;recv1,..;send`, so this is a valid address:
`192.168.1.0;224.4.4.4,225.5.5.5;226.6.6.6` where the send address is the last
part and the middle addresses are where packets are received.  If the network
part is unspecified, then the hostname is used to find the interface.  If there
is only one multicast address, then that is used for both sending and
receiving.

The transmit and receive window sizes are in number of packets.  Although many
messages can fit into a single packet, often the rate isn't high enough to
fill each packet, so this is a lower bound on the number of messages which
stay in memory for recovery.  The receive window memory is not used until there
is packet loss and a retransmission occurs.  Unrecoverable packet loss occurs
when the transmission window no longer has the sequences that are lost.  The
`mcast_loop`, when set to 1, allows two nodes to share the same network on
the same host.  This is useful for testing locally.

In addition to the multicast networking, an inbox protocol is used for point
to point messages.  The network specified in the multicast address is used
as the inbox network, with a random port.

The listen and connect addresses act similarily, two peers using different
methods will communicate if the multicast send address matches one of the
receive addresses and the inboxes are connected.

[options="header"]
|======================================================
| Field      |   Default    | Description              
| listen     | ;239.192.0.1 | Multicast address        
| connect    | ;239.192.0.1 | Multicast address        
| port       | 7239         | UDP port                 
| mtu        | 16384        | Maximum UDP packet size  
| txw_sqns   | 16384        | Send window size         
| rxw_sqns   | 16384        | Receive window size      
| mcast_loop | 0            | Loop through the host    
|======================================================

Example `tport_mypgm.yaml`:

----
  tport: mypgm
  type: pgm
  route:
    listen: 192.168.1.0;224.4.4.4
    port: 4444
    mtu: 16384
----

TCP Mesh
~~~~~~~~

A TCP mesh is a group of peers which automatically maintain connections with
every other peer.  When a new peer joins the mesh, it opens a connection with
all the other peers which are currently members of the mesh.

Only the initial peer listens passively, all the other peers discover the
members by connecting to the passive peer.

The timeout parameter causes the connecting peer to retry for this amount of
time.  When the timeout expires, the transport will not try to connect until
told to do so again.

[options="header"]
|======================================================
| Field      |   Default    | Description              
| listen     | *            | Passive listener         
| connect    | localhost    | Active joiner            
| port       | random       | Listener or connect port 
| timeout    | 15           | Active connect timeout   
|======================================================

Example `tport_mymesh.yaml`:

----
  tport: mymesh
  type: mesh
  route:
    listen: *
    connect: passive.host
    port: 9000
    timeout: 0
----

TCP Point-to-point
~~~~~~~~~~~~~~~~~~

A simple TCP connection from one host to another.  This is useful to create
ad-hoc topologies at the network boundaries.  The `edge` parameter causes
the passive peer to pool the connections on a single transport, similar to
a multicast transport.  This should only be done when the connectors do not
route messages, they only have one connection to the network.

[options="header"]
|======================================================
| Field      |   Default    | Description              
| listen     | *            | Passive listener         
| connect    | localhost    | Active joiner            
| port       | random       | Listener or connect port 
| timeout    | 15           | Active connect timeout   
| edge       | false        | A peer at the edge       
|======================================================

Example `tport_mytcp.yaml`:

----
  tport: mytcp
  type: tcp
  route:
    listen: *
    connect: passive.host
    port: 9001
    timeout: 0
----

Tib RV
~~~~~~

The RV protocol supports both the RV5 and RV6+ styles of clients.  The RV6+
clients use the daemon for the inbox endpoint and don't create sessions, the
RV5 clients use a unique session for each connection and allow an inbox reply
in the subscription start.  These differences cause decades old software
incompatabilities and pressure to reengineer legacy messaging systems.

There clients usually specify the network and service they want to connect,
which is different from the other clients.  When a client requests to connect
to a multicast network, the Rai MS `ms_server` will start a PGM transport for
it, unless an existing transport is already defined named with a `rv_` prefix
and a service numbered suffix.

When the `rv_7500` transport exists as a TCP mesh, then this network is
remapped to the predefined transport when a RV client uses the service 7500
and the multicast network specified by the client is ignored.  When no
multicast network is specified, then no Rai MS transport is created and
the existing transports are used.

Unlike a normal RV service, the Rai MS transports do not segregate by service
number.  When RV clients use the different services, like service 7500 and
service 7600, they will route publishes to each other.  The only way to
segregate RV traffic by service number is to run multiple instances of the
Rai MS `ms_server`.

[options="header"]
|======================================================
| Field      |   Default    | Description              
| listen     | *            | Passive listener  
| port       | random       | Listener port     
|======================================================

Example `tport_myrv.yaml`:

----
  tport: myrv
  type: rv
  route:
    listen: *
    port: 7500
----

NATS
~~~~

NATS is a pub/sub system that is similar to RV with respect to subject schema
with some extensions for queue groups and optionally persistent message
streaming.  The protocol support does not include the streaming components,
only the pub/sub and queue groups.  NATS does not have an inbox point-to-point
publish scheme, it relies on the client to create a unique subject for this
functionality.

[options="header"]
|======================================================
| Field      |   Default    | Description              
| listen     | *            | Passive listener  
| port       | random       | Listener port     
|======================================================

Example `tport_mynats.yaml`:

----
  tport: mynats
  type: nats
  route:
    listen: *
    port: 4222
----

Redis
~~~~~

Redis has a pub/sub component that has slightly different semantics, without a
reply subject for request/reply.  It also uses the term `channel` to refer to a
subscription.  A pattern subscription is separated by a psub operator, allowing
subscriptions and publishes to any series of bytes.  The data operators that
operate on cached structures like lists and sets, etc.  These commands are
available when a shared memory key value segment created and passed as an
argment to the server (example: -m sysv:raikv.shm), or defined as a value in
the parameters section of the config (example: map: "sysv:raikv.shm").

[options="header"]
|======================================================
| Field      |   Default    | Description              
| listen     | *            | Passive listener  
| port       | random       | Listener port     
|======================================================

Example `tport_myredis.yaml`:

----
  tport: myredis
  type: redis
  route:
    listen: *
    port: 6379
----

Telnet
~~~~~~

Telnet is a way to get a console prompt, but it doesn't start by default.  It
uses the same transport config as the pub/sub protocols.  It also can be used
by network configuration tools to install a configuration remotely.  A telnet
client signals the service that it has terminal capabilities which enables
command line editing.  


[options="header"]
|======================================================
| Field      |   Default    | Description              
| listen     | *            | Passive listener  
| port       | random       | Listener port     
|======================================================

Example `tport_mytelnet.yaml`:

----
  tport: mytelnet
  type: telnet
  route:
    listen: *
    port: 22
----

Web
~~~

Web handles http requests and websocket endpoints and integrates an web
application that can be used to graph activity and show internal tables.  The
web application is compiled into the server, so no external file access is
necessary.

[options="header"]
|======================================================
| Field      |   Default    | Description              
| listen     | *            | Passive listener  
| port       | random       | Listener port     
| http_dir   | none         | If set, serve files from directory
|======================================================

Example `tport_myweb.yaml`:

----
  tport: myweb
  type: web
  route:
    listen: *
    port: 80
    http_dir: "./"
----

Files located in the directory will override the internal files.  The html
files and websock requests also have a templating system which substitute
values from the server.  If `@(show ports)` appears in a html page, it is
replace with a html `<table>` of ports.  If `template "res" : @{show ports}` is
sent using a websocket, it expands to a JSON array off ports and the reply is
`"res" : [ports...]`.

Any of the commands from the console interface are now exposed on the http
endpoint.  Requesting "show ports" will respond with a JSON array of transports
with the current totals of messages and bytes:

----
$ wget -q -O - "http://localhost:80/?show ports"                                                                        
[{"tport":"rv.0", "type":"rv", "cost":1000, "fd":13, "bs":"", "br":"", "ms":"", "mr":"", "lat":"", "fl":"SLI", "address":"rv://127.0.0.1:7500"},
{"tport":"mesh4.1", "type":"mesh", "cost":1000, "fd":16, "bs":"", "br":"", "ms":"", "mr":"", "lat":"", "fl":"SLX", "address":"mesh://10.4.4.18:19500"},
{"tport":"primary.2", "type":"tcp", "cost":1000, "fd":18, "bs":29500, "br":47324, "ms":229, "mr":355, "lat":"26.5ms", "fl":"C", "address":"robotron.1@tcp://209.237.252.104:18500"},
{"tport":"secondary.3", "type":"tcp", "cost":1000, "fd":20, "bs":23276, "br":39134, "ms":181, "mr":311, "lat":"29.4ms", "fl":"C", "address":"edo.2@tcp://209.237.252.98:18500"}]
----

The websocket endpoint can also be used to subscribe subjects.  When a message
is published to the websocket, the format used is:

----
"subject" : { "field" : "value" }
----

This requires that the message can be converted to JSON or is already in JSON
format.
