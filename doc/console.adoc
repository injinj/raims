[[console]]
Console
-------

Description of the Console
~~~~~~~~~~~~~~~~~~~~~~~~~~

The console of `ms_server` is available when the -c option is used or when a
<<telnet>> protocol is defined.  It offers command line editing and
completions.  It can be used to define, start, or stop connections between
instances and also modify which IPC protocols are running for clients to use.
It also has many ways to examine and debug the network.

The output is usually colorized if the terminal supports it, with green and red
used for log messages (normal and error) and white used for cli command
execution results.  Printing messages received are also colorized, green for
field name, blue for field type, white for field values.

The user names and the transport names usually have an integer number appended
to them, for example `lex_a2.3` is the user `lex_a2` that has a `uid` of 3.
This indicates either the `uid` or the `tport_id` of the identifier.  The
string identifiers of users and transports can contain duplicates, since they
are identified using the bridge id.  The bridge id is a unique random 128 bit
nonce, the strings attached to the users and transports are tags which usually
are unique, but not necessarily.  The users and transports are kept in their
respective a tables and the `uid` and `tport_id` are indexes into these tables.
The `*` is often used for uid 0 so that it stands out, since it is the peer
that the console is attached to.  The `tport_id` of 0 is also special, that is
where the client protocols are attached through local IPC, for example, a TCP
connection to 127.0.0.1:7500.

The command string entered into the cli will execute if it has enough characters
to distinguish it from the prefixes of other commands.  If the string 'pi' is
entered, then the command `ping` will run, since 'pi' is a unique prefix of
`ping`.  The `show` prefix is optional when the command matches the second part
of the `show` command, so 'pe' will match and run the `show peers` command.
The shortened command `run t test` will match and run the `show running
transport test` command.

Help Screen
~~~~~~~~~~~

The following is the help screen, displayed when "help" is entered at the cli.

[%autowidth,options="header",grid="cols",stripes="even"]
|=============================================
| Command                                | Description
| link:#ping[ping] [U]                   | Ping peers and display latency of return
| link:#ping[tping] [U]                  | Ping peers with route trace flag
| link:#ping[mping] [P]                  | Multicast ping all peers using path P
| link:#remote[remote] U C               | Run command C remotely on peer U
| link:#conn_listen[connect] T           | Start tport connect
| link:#conn_listen[listen] T            | Start tport listener
| link:#conn_listen[shutdown] T          | Shutdown tport
| link:#conn_listen[network] S N         | Configure service and join network
| link:#conf_tran[configure transport] T    | Configure tport T
| link:#conf_tran[configure parameter] P V  | Configure parameter P = V
| link:#conf_tran[save]                     | Save current config as startup
| link:#show_subs[show subs] [U] [W]     | Show subscriptions of peers
| link:#show_seqno[show seqno] [W]       | Show subject seqno values for pub and sub
| link:#show_adjacency[show adjacency]   | Show the adjacency links
| link:#show_peers[show peers]           | Show active peers
| link:#show_ports[show ports] [T]       | Show the active ports
| link:#show_cost[show cost] [T]         | Show the port costs
| link:#show_status[show status] [T]     | Show the port status with any errors
| link:#show_routes[show routes] [P]     | Show the route for each peer for path P (0-3)
| link:#show_urls[show urls]             | Show urls of connected peers
| link:#show_tport[show tport] [T]       | Show the configured tports
| link:#show_user[show user] [U]         | Show the configured users
| link:#show_events[show events]         | Show event recorder
| link:#show_logs[show logs]             | Show current log buffer
| link:#show_counters[show counters]     | Show system seqno and time values
| link:#show_pubtype[show pubtype]       | Show system publish type received
| link:#show_inbox[show inbox] [U]       | Show inbox sequences
| link:#show_loss[show loss]             | Show message loss counters and time
| link:#show_skew[show skew]             | Show peer system clock skews
| link:#show_reachable[show reachable]   | Show reachable peers through active tports
| link:#show_tree[show tree] [U]         | Show multicast tree from me or U
| link:#show_path[show path] [P]         | Show multicast path P (0->3)
| link:#show_forward[show forward] [P]   | Show forwarding P (0->3)
| link:#show_fds[show fds]               | Show fd statistics
| link:#show_buffers[show buffers]       | Show fd buffer memory usage
| link:#show_windows[show windows]       | Show pub and sub window memory usage
| link:#show_blooms[show blooms] [P]     | Show bloom centric routes for path P (0-3)
| link:#show_match[show match] S         | Show users which have a bloom that match sub
| link:#show_graph[show graph]           | Show network description for node graph
| link:#show_cache[show cache]           | Show routing cache geom, hits and misses
| link:#show_poll[show poll]             | Show poll dispatch latency
| link:#conf_tran[show running]             | Show current config running
| link:#conf_tran[show running transport] T | Show transports running, T or all
| link:#conf_tran[show running service] S   | Show services running config, S or all
| link:#conf_tran[show running user] U      | Show users running config, U or all
| link:#conf_tran[show running group] G     | Show groups running config, G or all
| link:#conf_tran[show running parameter] P | Show parameters running config, P or all
| link:#conf_tran[show startup]             | Show startup config
| link:#conf_tran[show startup transport] T | Show transports startup, T or all
| link:#conf_tran[show startup service] S   | Show services startup config, S or all
| link:#conf_tran[show startup user] U      | Show users startup config, U or all
| link:#conf_tran[show startup group] G     | Show groups startup config, G or all
| link:#conf_tran[show startup parameter] P | Show parameters startup config, P or all
| link:#test_sub[sub] S [F]       | Subscribe subject S, output to file F
| link:#test_unsub[unsub] S [F]   | Unsubscribe subject S, stop output file F
| link:#test_psub[psub] W [F]     | Subscribe rv-wildcard W, output to file F
| link:#test_punsub[punsub] W [F] | Unsubscribe rv-wildcard W, stop output file F
| link:#test_gsub[gsub] W [F]     | Subscribe glob-wildcard W, output to file F
| link:#test_gunsub[gunsub] W [F] | Unsubscribe glob-wildcard W, stop output file F
| link:#test_pub[pub] S M       | Publish msg string M to subject S
| link:#test_trace[trace] S M   | Publish msg string M to subject S, with reply
| link:#test_ack[ack] S M       | Publish msg string M to subject S, with ack
| link:#test_rpc[rpc] S M       | Publish msg string M to subject S, with return
| link:#test_any[any] S M       | Publish msg string M to any subscriber of S
| link:#test_cancel[cancel]     | Cancel and show incomplete (ping, show subs)
| link:#log_mute[mute]          | Mute the log output
| link:#log_unmute[unmute]      | Unmute the log output
| link:#test_reseed[reseed]     | Reseed bloom filter
| link:#debug_log[debug] I      | Set debug flags to ival I
| link:#write_events[wevents] F | Write events to file
| link:#stop_die[die] [I]       | Exit without cleanup, with status 1 or I
| link:#stop_quit[quit/exit]    | Exit console
|=============================================

The arguments in square brackets are optional, the letters used above are:

- U -- User, the name of an `ms_server` instance, which is often the hostname
  of the machine.

- P -- Path, a multicast path, numbered 0 to 3.  This selects a precomputed
  path that all `ms_server` instances use to forward messages.  It will only
  be different when there are redundant links with a cost that is less or equal
  to the primary path 0.

- T -- Transport, the name of a connection endpoint that messages are routed
  through.

- S -- Service or Subject depending context.  The name or number of a service,
  for example 7500 is the default RV service.  A subject is any string of
  characters.

- N -- Network, formatted described in <<network_spec>>.

- G -- Group, defines a group of users, not currently used.

- F -- File, a path in the file system.

- M -- Message, a string of characters, as the console is limited to message
  formats that can be typed into the cli (string and json).

- I -- Integer

[[ping]]
Testing Connectivity with Ping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- ping [U]
- tping [U]
- mping [P]

These commands send a message to a peer and display the message returned.  The
`tping` command also sets the trace flag in the message sent so that all peers
along the path will also send a message back.  This is useful in the way that
traceroute is useful, to find an unusual latency report or dropped messages.

The `ping` and `tping` optionally have an argument that specifies the name of
the peer to send the message.  If no argument is used, then every peer
currently active will be sent a message.  These messages are sent over the link
that is handling the inbox point to point messages.  The subject of a `ping`
message uses the inbox format `_I.<nonce>.ping`, where the nonce identifies the
destination peer.  The return uses the `_I.<nonce>.N` inbox subject, where
nonce identifies the peer of the sending console.  The N part of the subject is
setup by the console to identify what the sending operation was and is used in
the reply field of the original message.

The `mping` use a multicast path instead of an inbox path.  The multicast path
is numbered and is added to the message header so that all peers which receive
and route this message will use the same path.  All peers that receive it will
send an inbox reply message, similar to `ping`.  The subject used by the sender
is `_M.ping`, which all peers are subscribed to.  The multicast paths are
numbered 0 to 3, so `mping 0` will use the first path, and `mping 3` will use
the last path.  Using different paths can be useful to check that all redundant
links in use are active and forwarding.  The reply also includes which port the
message was received on, which will match the path 3 network path.  The path 0
is often the same as the inbox path, except in the case of PGM, where inbox is
a UDP point to point protocol.

If the network is not yet stable, sometimes a ping operation will not complete.
When this occurs, use the `cancel` command to show the completed and the
incomplete values.  When a ping operation is started, the console estimates
the number of replies that are expected and waits for these to complete before
displaying the results.   The `tping` will display the acks of the message
as they are received but wait for the final results.

Example `ping`.

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[0]> ping
   user   | cost |   lat |     tport   |  peer_tport
----------+------+-------+-------------+-------------
 pic_a2.1 | 1000 | 189us | pic_amesh.2 |  pic_amesh.2
 pic_a4.3 | 1000 | 184us | pic_amesh.4 |  pic_amesh.4
 pic_a3.2 | 1000 | 214us | pic_amesh.3 |  pic_amesh.3
  pic_a.4 | 1000 | 219us | pic_amesh.5 |  pic_amesh.6
 lex_a.29 | 2000 | 296us | pic_amesh.5 |   fo_mesh.12
 lee_a.26 | 2000 | 340us | pic_amesh.5 |   fo_mesh.12
lex_a4.17 | 3000 | 389us | pic_amesh.5 |  lex_amesh.5
...
----

Example `mping`.

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[1]> mping 1
   user   | cost |   lat  |     tport   |  peer_tport
----------+------+--------+-------------+-------------
  pic_a.4 | 1000 |  146us | pic_amesh.5 |  pic_amesh.6
 pic_a2.1 | 1000 |  158us | pic_amesh.2 |  pic_amesh.2
 pic_a4.3 | 1000 |  199us | pic_amesh.4 |  pic_amesh.4
 pic_a3.2 | 1000 |  245us | pic_amesh.3 |  pic_amesh.3
  edo_a.9 | 2000 |  265us | pic_amesh.5 |   fo_mesh.12
 lex_a.29 | 2000 |  278us | pic_amesh.5 |   fo_mesh.12
 lee_a.26 | 2000 |  279us | pic_amesh.5 |   fo_mesh.12
...
----

The `tport` field is where the reply inbox message was received, the
`peer_tport` is where the `ping` message was received at the peer.

[[remote]]
Remote Command Execution
~~~~~~~~~~~~~~~~~~~~~~~~

- remote U C

`Remote` will message a command to another peer, run it in it's console and
return the result.  This is useful because most often, a peer will not have a
console, a web interface, or a telnet protocol active.  Without `remote`, the
peer would need to be restarted in order to change the configuration or start a
console.  With `remote`, you could connect a peer with authentication, encryption
and a console to the network temporarily, make a change, then disconnect the
peer.

Example of `remote`.

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[4]> rem lee_a1 show pubtype
from lee_a1.19:
      type       | recv_count | send_count
-----------------+------------+-----------
 u_session_hello |          0 |          1
    u_session_hb |      16217 |      16218
      u_peer_add |        113 |         31
  u_bloom_filter |         39 |          3
     u_adjacency |         67 |          4
...
----

[[conf_tran]]
Update and Show the Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- configure transport T
- configure parameter P V
- save
- show running
- show running transport T
- show running service S
- show running user U
- show running group G
- show running parameter P
- show startup
- show startup transport T
- show startup service S
- show startup user U
- show startup group G
- show startup parameter P

These commands show and modify the running configuration.  The `save` command
write the running config to the startup config, when the directory and files
are writable.

The `show running` and `show startup` will print the config tree in yaml
to the console.  The running configuration may have some dynamically created
users and protocols which are created as a result of the startup config.  A
dynamically created user that is not preconfigured is one of these.  These
will show in `running`, but will not save to `startup`.

Using the `configure transport` command is the most often used command of
these.  It will update the currently running transports as well as add new
ones.  If it is used to modify an existing transport that is already running,
the new settings won't change the active transport until it is restarted
with `shutdown` and `connect` or `listen`.  The configuration details of
transports are described in <<network>>, and the details of the parameters
are described in <<parameters>>.  Most of the parameters are only applied
at startup, so changing them will have an effect only when saved and the
process restarted.

Example of `configure transport` and `show running transport`.

[source%nowrap]
----
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[110]> configure transport mesh
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[111](mesh)> type mesh
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[112](mesh)> port 9000
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[113](mesh)> connect host1
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[114](mesh)> connect2 host2
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[115](mesh)> listen *
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[116](mesh)> q
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[117]> show running transports mesh
transports:
  - tport: mesh
    type: mesh
    route:
      port: 9000
      connect: host1
      connect2: host2
      listen: "*"
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[123]> configure transport test type tcp port 9000 connect host1
Transport (test) updated
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[124]> show running transports test
transports:
  - tport: test
    type: tcp
    route:
      port: 9000
      connect: host1
----

The first `configure` command enters into a cli sub command mode where only the
fields of the transport can be entered.  The second `configure` command sets
all of the fields on one line.

The commands `show service` and `show group` have limited usefulness at in the
current implementation, since only one service is used per `ms_server` instance
and groups do not have operational functionality yet, eventually they will be
used for access control lists.

[[conn_listen]]
Transport Start and Stop
~~~~~~~~~~~~~~~~~~~~~~~~

- connect T
- listen T
- shutdown T
- network S N

The transport T is defined before using the `connect`, `listen`, `shutdown`
commands.  The `network` command configures the transport if not already
configured, runs it, and also attaches a service to it.  The configuration of
the transports is described in <<network>>.

Example of `connect`, `listen`, `shutdown`.

[source%nowrap]
----
chex.rvd[L+jUn266ADoL2fBschoqUg]@chex[108]> configure transport test type tcp port 9000 connect lexx.rai
Transport (test) updated
chex.rvd[L+jUn266ADoL2fBschoqUg]@chex[109]> connect test
Transport (test) started connecting
chex.rvd[L+jUn266ADoL2fBschoqUg]@chex[110]> shutdown test
Transport (test) is running tport 1
Transport (test) shutdown (1 instances down)
----

The Show Commands
~~~~~~~~~~~~~~~~~

[[show_subs]]
- show subs [U] [W]

Show the subscriptions active for user or for all users.  The `W` is a substring
for partial matches.  This command uses inbox RPC calls to `_I.<nonce>.subs`
for all users which `U` specifies.  The `*` user matches all users, so the `W`
argument can be specified.

Example, show all subscriptions for every user:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[38]> show subs
   user   |                               subject
----------+-------------------------------------------------------------------
 pic_a1.* |                                       _7603._INBOX.0AB98FB4.DAEMON
          |                       (p) _7603._INBOX.0AB98FB4.763E17AA51E2DEF0.>
          |                                                               test
----------+-------------------------------------------------------------------
 pic_a2.1 |                                       _7606._INBOX.173D29A5.DAEMON
          |                       (p) _7606._INBOX.173D29A5.763E17AA5271FEF0.>
----------+-------------------------------------------------------------------
 pic_a3.2 |                                       _7500._INBOX.0072DD0A.DAEMON
          |                       (p) _7500._INBOX.0072DD0A.663E17AA514B7DD0.>
          |                                               _7500.RSF3.REC.MOT.B
----------+-------------------------------------------------------------------
 pic_a4.3 |                                       _7500._INBOX.68AD2F1B.DAEMON
          |                       (p) _7500._INBOX.68AD2F1B.763E17AA50777DD0.>
          |                                            _7500.RSF4.REC.DEM=.NaE
          |                                             _7500.RSF4.REC.NAI.NaE
...
----

The `(p)` strings before the subject indicates that the subject was subscribed
as a pattern.

Example, show all subscriptions which have the substring DAEMON:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[41]> show subs * DAEMON
   user   |            subject
----------+-----------------------------
 pic_a1.* | _7603._INBOX.0AB98FB4.DAEMON
----------+-----------------------------
 pic_a2.1 | _7606._INBOX.173D29A5.DAEMON
----------+-----------------------------
 pic_a3.2 | _7500._INBOX.0072DD0A.DAEMON
----------+-----------------------------
 pic_a4.3 | _7500._INBOX.68AD2F1B.DAEMON
...
----

Example, show subscriptions active at user edo_a3:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[44]> show subs edo_a3
   user   |                    subject
----------+---------------------------------------------
edo_a3.13 |                 _7500._INBOX.C6AD7566.DAEMON
          | (p) _7500._INBOX.C6AD7566.763E17AA40C28DD0.>
          |                          _7500.RSF5.REC.DD.N
          |                         _7500.RSF5.REC.BBN.N
...
----


[[show_seqno]]
- show seqno [W]

Show the sequences of the subjects received and published.  The peers with IPC
or console subscribers or publishers track the sequences the subjects to ensure
the stream is completely serialized and notify of a data loss error when it is
not in sequence.  The details of how this works is described in
<<message_loss>>.  This command only operates on the local sequence windows,
the link:#show_windows[show windows] command shows the memory usage of these.

The W is a substring that matches the subject so that the subjects in the
window can be filtered.  Without `W`, all of the subjects are printed.

Example, show the sequences of the subjects which contain ORCL:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[4]> show seqno ORCL
  source   |  seqno |        start      |        time       |         subject
-----------+--------+-------------------+-------------------+---------------------------
       ipc |  52581 | 0207 10:16:16.108 | 0207 23:51:11.441 |      _7500.RSF4.REC.ORCL.O
       ipc | 145911 | 0207 10:20:50.986 | 0208 00:07:24.401 |      _7500.RSF9.REC.ORCL.O
       ipc | 128244 | 0207 10:25:25.864 | 0208 00:17:18.041 |      _7500.RSF7.REC.ORCL.O
 dex_a2.21 | 542769 | 0207 10:03:05.834 | 0208 00:22:42.401 | _7605._TIC.RSF5.REC.ORCL.O
 dex_a1.20 | 542769 | 0207 10:03:05.834 | 0208 00:22:42.281 | _7602._TIC.RSF2.REC.ORCL.O
 ...
----

The source is the publisher, so IPC indicates that the client attached to the
lex_a1 has published these messages, and dex_a2, dex_a1 indicate that these
messages were received from clients attached to those peers (or the console).
The start is the first time in the time frame that the subject was seen, the
time is the last time it was seen.  New time frames occur when the network link
state database changes, since the sequence number time frame reference jump
between old and new time frames and the seqno base is linear.

[[show_adjacency]]
- show adjacency

Show the adjacency tables.  This command dumps the current link state database.
It shows which peer has a link to another peer through which tport and the cost
of the link (of path 0).

Example:

[source%nowrap]
----
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[127]> show adj
   user    |     adj    |     tport    | type | cost
-----------+------------+--------------+------+-----
    chex.* |            |        ipc.0 |  ipc | 1000
           |    lex_a.1 |       test.1 |  tcp | 1000
-----------+------------+--------------+------+-----
   lex_a.1 |    edo_a.2 |    fo_mesh.4 | mesh | 1000
           |   lex_a2.3 |  lex_amesh.5 | mesh | 1000
           |   lex_a1.4 |  lex_amesh.6 | mesh | 1000
           |   lex_a3.5 |  lex_amesh.7 | mesh | 1000
           |   lex_a4.6 |  lex_amesh.8 | mesh | 1000
           |   robo_a.7 |    fo_mesh.9 | mesh | 1000
           |   lee_a.16 |   fo_mesh.10 | mesh | 1000
           |   dex_a.21 |   fo_mesh.11 | mesh | 1000
           |   pic_a.26 |   fo_mesh.12 | mesh | 1000
           |     chex.* |   lex_tcp.13 |  tcp | 1000
-----------+------------+--------------+------+-----
   edo_a.2 |   edo_a4.8 |  edo_amesh.4 | mesh | 1000
           |   edo_a3.9 |  edo_amesh.5 | mesh | 1000
...
----

The `user` is the peer that is maintaining the links that follow.  It sends a
link state update messages when a link is added, dropped or cost is changed.

The `adj` field is the peer which is directly attached to `user` through the
`tport`.  The `tport` is the name that `user` is labeling this link.  The
`tport_id` number that follows the name (`fo_mesh` + .4) is the index into the
user's transport table.  The `type` and `cost` fields are also sent by `user`
in the link state update.

[[show_peers]]
- show peers

Shows info about the peers in the network that are active.

Example:

[source%nowrap]
----
chex.rvd[LQ9YfNwX/KtuiniQNvVkQg]@chex[129]> show peers
   user    |         bridge         | sub |   seq | link |   lat  |   max  |   avg  |  tport | cost |               address
-----------+------------------------+-----+-------+------+--------+--------+--------+--------+------+-----------------------------------
    chex.* | LQ9YfNwX/KtuiniQNvVkQg |   2 |     0 |    1 |        |        |        |        |      |
   lex_a.1 | itdZ1mlWSlXyT9BcLI9bhg |   2 |     0 |    9 | 21.9ms |   22ms | 21.9ms | test.1 | 1000 |         tcp://209.237.252.105:9000
   edo_a.2 | 7LdF5BgMITq0f+7UZKdBqg |   2 |     0 |    5 | 22.1ms | 22.7ms | 22.2ms | test.1 | 2000 | lex_a.1@tcp://209.237.252.105:9000
  lex_a2.3 | G26tiXX/uqnA3PwDb4j60A |  74 | 21608 |    4 |   22ms | 22.5ms |   22ms | test.1 | 2000 | lex_a.1@tcp://209.237.252.105:9000
  lex_a1.4 | L0MOCmhQpwX2JqsBjYBypA | 115 |   113 |    4 |   22ms | 22.1ms | 21.9ms | test.1 | 2000 | lex_a.1@tcp://209.237.252.105:9000
----

The `bridge` is the 128 bit random nonce created on startup by each peer.  It
uniquely identifies the peer instance.

The `sub` field are the number of subscriptions that are active.  This number is
a counter in the bloom filter that is updated by the peer when subjects and
patterns are added or removed.  It always contains at least 2 entries, one for
the `_I.<nonce>.>` inbox pattern and one for the `_M.>` multicast pattern.

The `seq` field is the sequence number for each subscription operation.  It is
serialized so that all subscriptions happen in the same order as the peer.

The `link` field is the sequence number for each link state update.  It is also
serialized so that adjacency table modifications occur in order.

The `lat`, `max`, `avg` are ping round trip times that are sent 1.5x the
heartbeat interval to a random peer.  They are tracked for at least an hour
before being rotated.

The `tport`, `cost`, and `address` reference the inbox route to peer.

[[show_ports]]
- show ports [T]

Show info about transports that are active on the network.

Example:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[47]> show ports
    tport   |  type  | cost | fd |      bs     |    br    |     ms    |   mr   |   lat |  idle  |  fl  |                   address
------------+--------+------+----+-------------+----------+-----------+--------+-------+--------+------+-------------------------------------------
       rv.0 |     rv |      | 12 |             |          |           |        |       | 27.8hr |   LI |                        rv://127.0.0.1:7500
pic_amesh.1 |   mesh | 1000 | 18 |             |          |           |        |       | 27.8hr | LXCD |                    mesh://172.18.0.2:34344
pic_amesh.2 |   mesh | 1000 | 19 |     3250008 |  3248028 |     10747 |  10747 | 173us | 1.99se |    X |           pic_a2.1@mesh://172.18.0.3:39340
pic_amesh.3 |   mesh | 1000 | 21 |     3248424 |  5785922 |     10733 |  32929 | 240us | 1.39se |    X |           pic_a3.2@mesh://172.18.0.4:41320
pic_amesh.4 |   mesh | 1000 | 23 |     3355474 |  5801830 |     10822 |  33084 | 225us |  835ms |    X |           pic_a4.3@mesh://172.18.0.5:43846
pic_amesh.5 |   mesh | 1000 | 25 | 36957142584 | 29991114 | 100159342 | 245786 | 166us | 1.06ms |    X |            pic_a.4@mesh://172.18.0.1:57204
----

The `tport`, `type` are configured, and the `cost` is either configured or
advertised by the peer in it's link state message.  If a transport is internal,
like an IPC transport, then it doesn't have a cost associated with it.

The `fd` field is the endpoint for the transport, usually a listener or a `fd`
assigned to the transport.  There are usually one or more fds within the
transport that carry out the reading and writing of data to a network endpoint.

The fields `bs`, `br`, `ms`, and `mr` fields are bytes, messages sent and
received, which are collected from all the fds within the transport.

The `idle` is the last time a message event occurred.

The `fl` field are flags that are set on the transport.  Each character is a
different flag:

- `L` -- has a TCP listener
- `M` -- is a PGM multicast transport
- `X` -- is a mesh transport
- `C` -- is or was actively connecting the link
- `T` -- was accepted from a TCP listener
- `E` -- is marked as an edge link, there is no routing on the other side
- `I` -- is an IPC transport, which is are client endpoints
- `D` -- resolves the link using a multicast device
- `-` -- is shutdown
- `*` -- connecting in progress

The `address` field is the address at the peer when TCP is used and the
multicast address when PGM is used.

[[show_cost]]
- show cost [T]

This is similar to link:#show_ports[show ports] except that all 4 costs are
printed for each transport.

Example:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[49]> show cost pic_amesh
    tport   |  type  | cost | cost2 | cost3 | cost4 | fd |  fl  |                   address
------------+--------+------+-------+-------+-------+----+------+-------------------------------------------
pic_amesh.1 |   mesh | 1000 |  1000 |  1000 |  1000 | 18 | LXCD |                    mesh://172.18.0.2:34344
pic_amesh.2 |   mesh | 1000 |  1000 |  1000 |  1000 | 19 |    X |           pic_a2.1@mesh://172.18.0.3:39340
pic_amesh.3 |   mesh | 1000 |  1000 |  1000 |  1000 | 21 |    X |           pic_a3.2@mesh://172.18.0.4:41320
pic_amesh.4 |   mesh | 1000 |  1000 |  1000 |  1000 | 23 |    X |           pic_a4.3@mesh://172.18.0.5:43846
pic_amesh.5 |   mesh | 1000 |  1000 |  1000 |  1000 | 25 |    X |            pic_a.4@mesh://172.18.0.1:57204
...
----

[[show_status]]
- show status [T]

Similar to link:#show_ports[show ports] with a status errno if the system
reported an error on a link.  When everything is normal, the address is printed
instead.

Example:

----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[50]> show status pic_amesh
    tport   | type | fd |  fl  |              status
------------+------+----+------+---------------------------------
pic_amesh.1 | mesh | 18 | LXCD | mesh://172.18.0.2:34344
pic_amesh.2 | mesh | 19 |    X | pic_a2.1@mesh://172.18.0.3:39340
pic_amesh.3 | mesh | 21 |    X | pic_a3.2@mesh://172.18.0.4:41320
pic_amesh.4 | mesh | 23 |    X | pic_a4.3@mesh://172.18.0.5:43846
pic_amesh.5 | mesh | 25 |    X | pic_a.4@mesh://172.18.0.1:57204
...
----

[[show_routes]]
- show routes [P]

Show the routes.  This shows how all the peers are connected and which port
would be used to send and receive messages to/from the peer.  It also displays
which transports have been used in order to reach the peer.

Example:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[52]> show routes
   user   |     tport   |      state    | cost |   path  |   lat  | fd |               route
----------+-------------+---------------+------+---------+--------+----+---------------------------------
 pic_a2.1 | pic_amesh.2 | inbox,mesh,hb | 1000 | 0,1,2,3 |  143us | 19 | pic_a2.1@mesh://172.18.0.3:39340
          | pic_amesh.3 |               | 2000 |         |        | 21 | pic_a3.2@mesh://172.18.0.4:41320
          | pic_amesh.4 |               | 2000 |         |        | 23 | pic_a4.3@mesh://172.18.0.5:43846
          | pic_amesh.5 |               | 2000 |         |        | 25 |  pic_a.4@mesh://172.18.0.1:57204
...
----

This shows that user `pic_a2` messages have been received or sent through these
transports.  The secondary transports are often used on startup when the other
links are not yet active or when a link fails.

The `state` of the transport has these values:

- `inbox` -- transport is the path for the inbox route
- `mesh` -- transport is part of a mesh
- `hb` -- transport is directly connected and has a heartbeat
- `ucast` -- transport has a point to point UDP protocol
- `usrc` -- transport uses a point to point UDP protocol to reach another peer

The `cost` is the link cost of the path P argument, or 0 when not specified.

The `path` field enumerates which transport is used to reach peer for each path.

The `lat`, `fd` are the same as link:#show_ports[show ports].

The `route` is the directly connected peer address that a message is sent or
received.

[[show_urls]]
- show urls

Show the local and peer addresses as well as the url used to resolve the
address of the peer.  This is useful for mesh and multicast type networks since
the endpoints are sometimes resolved through exchanging messages with the
network.   In the case of a mesh transport, a mesh url database is exchanged
and links are established with all the peers that are in the mesh.  The
multicast PGM transport exchanges the unicast UDP endpoints for all the peers
that are on the transport.

Example:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[54]> show urls
   user   |     tport   |      state    | cost |    mesh   | fd |            url          |           local         |          remote
----------+-------------+---------------+------+-----------+----+-------------------------+-------------------------+------------------------
          |       ipc.0 |            LI |      |           | 11 |                         |    ipc://127.0.0.1:7500 |   ipc://127.0.0.1:43992
          | pic_amesh.1 |          LXCD |      | pic_amesh | 17 | mesh://172.18.0.2:34344 |                         |
 pic_a2.1 | pic_amesh.2 |             X |      | pic_amesh | 20 | mesh://172.18.0.3:44108 | mesh://172.18.0.2:34344 | mesh://172.18.0.3:39340
 pic_a3.2 | pic_amesh.3 |             X |      | pic_amesh | 22 | mesh://172.18.0.4:42851 | mesh://172.18.0.2:34344 | mesh://172.18.0.4:41320
 pic_a4.3 | pic_amesh.4 |             X |      | pic_amesh | 24 | mesh://172.18.0.5:45836 | mesh://172.18.0.2:34344 | mesh://172.18.0.5:43846
  pic_a.4 | pic_amesh.5 |             X |      | pic_amesh | 26 | mesh://172.18.0.1:36262 | mesh://172.18.0.2:34344 | mesh://172.18.0.1:57204
----------+-------------+---------------+------+-----------+----+-------------------------+-------------------------+------------------------
 pic_a2.1 | pic_amesh.2 | inbox,mesh,hb | 1000 | pic_amesh | 19 | mesh://172.18.0.3:44108 | mesh://172.18.0.2:34344 | mesh://172.18.0.3:39340
          | pic_amesh.3 |               | 2000 | pic_amesh | 21 |                         |                         |
          | pic_amesh.4 |               | 2000 | pic_amesh | 23 |                         |                         |
          | pic_amesh.5 |               | 2000 | pic_amesh | 25 |                         |                         |
----

The top section is similar to link:#show_ports[show ports] with addition of the
urls.

The following sections is similar to link:#show_routes[show routes] with the
addition of the urls for each user.

The `url` field is resolved by exchanging messages.  The `local` and `remote`
are addresses assigned to the connection.  Since a mesh may be actively
connected by either peer, since all peers passive listeners and some have
active connections.  The newer peers will usually have the active connections
and the older peers will have accepted connections.  The local and remote
addresses will reflect that, since the accepted peers are assigned an address
by the system and the connecting peers use the `url` address to connect.

[[show_tport]]
- show tport [T]

Show the state of the transports.  This prints the configured transport and
whether it is active or not.  The other transport `show` commands will only
show the active transports.  This will show the ones configured but not active
as well.

Example:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[55]> show tport
   tport  |  type  |    state  |        listen       |             connect            |    device
----------+--------+-----------+---------------------+--------------------------------+------------
pic_amesh |   mesh | accepting |                     |                                | mesh://eth0
       rv |     rv | accepting | rv://127.0.0.1:7500 |                                |
      tel | telnet | accepting |     telnet://*:2222 |                                |
      ipc |    ipc |       ipc |                     |                                |
  rvd.ipc |    ipc |         - |                     |                                |
     eth0 |   name |         - |                     | name://eth0;239.23.22.217:8327 |
     test |    tcp |         - |                     |        tcp://robotron.rai:9000 |
----

The `listen`, `connect`, and `device` fields show how the transport is
configured to resolve the connections.

[[show_user]]
- show user [U]

Show the users configured.

Example:

[source%nowrap]
----
chex.test[OsGpIaCbYCJbhnUVEp19Uw]@chex[135]> show users
uid | user |  svc |        create        | expires
----+------+------+----------------------+--------
  0 | chex | test | 1675847381.440084399 |
    | dyna | test | 1675847381.440129724 |
    | ruby | test | 1675847381.440176492 |
    | zero | test | 1675847419.072423168 |
----

[[show_events]]
- show events

The system tracks the authentication and transport and link state events in a
buffer that rotates every 4096 entries.  This is a compact table that has 6
integer fields that map to a time stamp, uids, transports and enumerated values
depending on event type.  These events are useful for resolving what happened
to the network after something went wrong.

Example of an event log:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[59]> show events
       stamp      |     tport   |    user   |    peer   |       event     |         data
------------------+-------------+-----------+-----------+-----------------+--------------------
0206 22:09:22.606 |             |  pic_a1.* |           |         startup |
0206 22:09:22.607 |       ipc.0 |  pic_a1.* |           |      on_connect |              listen
0206 22:09:22.607 | pic_amesh.1 |  pic_a1.* |     (aes) |      on_connect |              listen
0206 22:09:22.607 |     (mcast) |  pic_a1.* |           |      send_hello |
0206 22:09:23.301 | pic_amesh.2 |  pic_a1.* |     (aes) |      on_connect |         mesh_accept
0206 22:09:23.327 |             |  pic_a1.* |           |        converge |           add_tport
0206 22:09:23.340 | pic_amesh.2 |  pic_a2.1 |  pic_a1.* |  add_user_route |            neighbor
0206 22:09:23.340 | pic_amesh.2 |  pic_a1.* |  pic_a2.1 |  send_challenge |               hello
0206 22:09:23.342 | pic_amesh.2 |  pic_a2.1 |           |  recv_challenge |           handshake
0206 22:09:23.342 |             |  pic_a2.1 |    (ecdh) |        auth_add |           handshake
0206 22:09:23.342 |     (mcast) |  pic_a1.* |  pic_a2.1 | send_adj_change |                 add
0206 22:09:23.342 | pic_amesh.2 |  pic_a2.1 |           |      send_trust |             in_mesh
0206 22:09:23.342 | pic_amesh.2 |  pic_a2.1 |           |    recv_peer_db |           add_route
0206 22:09:23.342 | pic_amesh.2 |  pic_a2.1 |  pic_a1.* | recv_adj_change |          update_adj
0206 22:09:23.367 |             |  pic_a1.* |           |        converge |          adj_change
0206 22:09:23.889 | pic_amesh.3 |  pic_a1.* |     (aes) |      on_connect |         mesh_accept
0206 22:09:23.927 |             |  pic_a1.* |           |        converge |           add_tport
0206 22:09:23.928 | pic_amesh.3 |  pic_a3.2 |  pic_a1.* |  add_user_route |            neighbor
----

The events that are logged are:

[%autowidth,options="header",grid="cols",stripes="even"]
|=============================================
| Event | Description
| startup | Initial event, time of start
| on_connect | Transport listen, connect, or accept occurred
| on_shutdown | Transport connection was closed or shutdown
| on_timeout | Transport connection timed out
| auth_add | Peer was authenticated and is now trusted
| auth_remove | Peer authentication is dropped
| send_challenge | An authentication challenge is sent to peer
| recv_challenge | An authentication challenge is received from peer
| send_trust | Authentication was successful, sent trust message
| recv_trust | Peer notified that my node is now authenticated
| add_user_route | Route to peer is found and the transport is labeled
| hb_queue | Peer is added to the heartbeat timeout queue
| hb_timeout | Peer heartbeat was not received within it's interval
| send_hello | Transport is initialized by sending a hello message
| recv_bye | Peer intends to leave the network and sends a bye message
| recv_add_route | Received a message that a peer was added to the network
| recv_peer_db | All the peers that are known are exchanged with a new peer
| send_add_route | Send a message when a peer is added to the network
| send_peer_del | Send a message when peer is removed from the network
| sync_result | Peer sync message was received, initialize peer state
| send_sync_req | Request a peer sync after new peer is notified
| recv_sync_req | Receive a sync request for my node or another peer
| recv_sync_fail | Receive a sync request for an unknown peer
| send_adj_change | Send a link state update message, add or remove link
| recv_adj_change | Received a link state update message
| send_adj_req | Link state for peer is stale, request the current link state
| recv_adj_req | Receive a request for the current link state
| send_adj | Send the current link state to a peer
| recv_adj_result | Receive the current link state from a peer
| resize_bloom | Resize my peers bloom filter and sent it to the network
| recv_bloom | Received a peers bloom filter
| converge | The network has no missing link states and is completely connected
|=============================================

[[show_logs]]
- show logs

The last log 64K bytes of the log is buffered in the process.  This command
shows the this buffer.

[[show_counters]]
- show counters

Show the counters of heartbeat, inbox, and ping subjects.

Example:

[source%nowrap]
----
pic_a1.rvd[CrmPtIc8B3ZedgdVTW7XOQ]@pic_a1[60]> show counters
   user   |        start      | hb seqno |       hb time     | snd ibx | rcv ibx | ping snd |     ping stime    | pong rcv | ping rcv
----------+-------------------+----------+-------------------+---------+---------+----------+-------------------+----------+---------
 pic_a1.* | 0206 22:09:22.606 |          |                   |         |         |          |                   |          |
 pic_a2.1 | 0206 22:09:23.219 |    17021 | 0208 20:52:00.940 |      19 |      23 |      454 | 0208 20:50:22.608 |      454 |      442
 pic_a3.2 | 0206 22:09:23.806 |    17021 | 0208 20:51:51.687 |      18 |     149 |      438 | 0208 20:50:43.808 |      438 |      444
 pic_a4.3 | 0206 22:09:24.401 |    17020 | 0208 20:51:52.241 |      29 |     125 |      427 | 0208 20:51:00.008 |      427 |      438
  pic_a.4 | 0206 22:09:24.433 |    17020 | 0208 20:51:52.275 |      35 |      37 |      422 | 0208 20:51:21.608 |      422 |      426
robo_a3.5 | 0206 22:09:06.260 |        0 |                   |      11 |      98 |      427 | 0208 20:51:40.528 |      427 |      421
robo_a2.6 | 0206 22:09:05.371 |        0 |                   |      11 |      15 |      424 | 0208 20:51:50.168 |      424 |      423
robo_a4.7 | 0206 22:09:07.183 |        0 |                   |      11 |      95 |      420 | 0208 20:41:30.568 |      420 |      418
robo_a1.8 | 0206 22:09:04.452 |        0 |                   |      11 |      15 |      423 | 0208 20:41:48.848 |      423 |      424
  edo_a.9 | 0206 22:09:12.993 |        0 |                   |       2 |      20 |      422 | 0208 20:42:05.808 |      422 |      419
----

The `start` field is when the process started.  The `hb seqno` and `hb time`
track the last heartbeat received from the peer when it is directly connected.
The `snd ibx`, `rcv ibx` are counters for many of the `_I.<nonce>.` subjects
which guard against repeats.  These are point to point messages, the peer has
the same counters which should match these.  The link:#show_inbox[show inbox]
command will show the last 32 of these sequences.  The `ping` and `pong`
sequences have their own counters, since these are used to check connectivity
between peers and are expected to have loss when the network is unstable.

[[show_pubtype]]
- show pubtype

When a message header is created or unpacked, a counter of the subject class is
incremented.  This shows these counters.  These are only messages that are
processed by the network, it is possible that two clients within the IPC
transport are exchanging messages, these are not counted.

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[7]> show pubtype
      type       | recv_count | send_count
-----------------+------------+-----------
 u_session_hello |          0 |          1
    u_session_hb |      68761 |      68765
      u_peer_add |        134 |         35
      u_peer_del |         16 |          4
  u_bloom_filter |         39 |          3
     u_adjacency |        115 |          4
      u_sub_join |     224621 |         24
     u_sub_leave |     223689 |          0
    u_psub_start |        110 |         89
    u_inbox_auth |          4 |          8
    u_inbox_subs |         10 |          0
    u_inbox_ping |      12476 |      12529
    u_inbox_pong |      12529 |      12481
     u_inbox_rem |          1 |          0
   u_inbox_resub |          0 |        202
 u_inbox_add_rte |          4 |          4
u_inbox_sync_req |          2 |         30
u_inbox_sync_rpy |         29 |          0
 u_inbox_adj_req |          3 |         10
 u_inbox_adj_rpy |         21 |          6
     u_inbox_ack |          0 |          1
     u_inbox_any |          0 |     224476
         u_inbox |          0 |          1
    u_mcast_ping |          5 |          0
 u_inbox_any_rte |         80 |          0
   mcast_subject | 1528812397 |          0
----

[[show_inbox]]
- show inbox [U]

Show the types of the last 32 system RPC messages sent and received for each
peer.  Some peers may not have any of these if they are not directly connected.

This is an example of a peer attached to the console connecting to a larger
network:

[source%nowrap]
----
chex.rvd[xpO5ODZvoOcUMJ60QVaSBg]@chex[139]> inbox
  user  | send seqno |     send type    | recv seqno |     recv type
--------+------------+------------------+------------+-----------------
lex_a.1 |          1 |     u_inbox_auth |          1 | u_inbox_sync_rpy
        |          2 |  u_inbox_add_rte |          2 |     u_inbox_auth
        |          3 |  u_inbox_adj_req |          3 |  u_inbox_add_rte
        |          4 | u_inbox_sync_req |          4 |  u_inbox_adj_rpy
        |          5 | u_inbox_sync_req |          5 | u_inbox_sync_rpy
        |          6 | u_inbox_sync_req |          6 | u_inbox_sync_rpy
        |          7 | u_inbox_sync_req |          7 | u_inbox_sync_rpy
        |          8 | u_inbox_sync_req |          8 | u_inbox_sync_rpy
...
----

The first 3 sequences are the result of authentication, which causes both peers
to exchange all their known peers.  The following `u_inbox_sync_req` and
`u_inbox_sync_rpy` pairs are used to request the peers which are not yet
authenticated.  In this case, the connecting peer has no peers and the peer
attached to the network has lots of peers that need synchronizing.

[[show_loss]]
- show loss

Show the counters of repeated messages (old message sequences), messages not
subscribed, have message loss, or have inbox loss.

When a message is repeated or not subscribed, a counter is incremented and the
message is tossed.  These types of events can occur through normal operation
and don't have an impact on clients.

The repeated messages can occur during network instability and not subscribed
messages can occur because an unsubscribe has not yet reached the publisher or
because the bloom filter did not filter the subject.

The message loss counters are more critical to correct behavior, since this
indicates that messages did not reach all subscriptions.  The inbox message
loss can occur normally since these are used to synchronize peers during
network instability, they are used to stabilize the network.

The point to point messages using the `_INBOX` prefix will also use the inbox
sequences, but even these are not as critical since clients will have timeouts
and retry the operation that uses an `_INBOX`

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[11]> show loss
   user    | repeat | rep time | not sub | not time | msg loss |      loss time    | ibx loss |      ibx time
-----------+--------+----------+---------+----------+----------+-------------------+----------+------------------
  lex_a2.1 |      0 |          |       0 |          |        0 |                   |        0 |
  lex_a3.2 |      0 |          |       0 |          |        0 |                   |        0 |
  lex_a4.3 |      0 |          |       0 |          |        0 |                   |        0 |
   edo_a.5 |      0 |          |       0 |          |        0 |                   |        0 |
  robo_a.6 |      0 |          |       0 |          |        0 |                   |        0 |
  edo_a4.7 |      0 |          |       0 |          |        0 |                   |        1 | 0209 08:22:25.120
  edo_a3.8 |      0 |          |       0 |          |        0 |                   |        1 | 0209 08:22:25.120
  edo_a1.9 |      0 |          |       0 |          |      640 | 0209 08:24:31.960 |        0 |
 edo_a2.10 |      0 |          |       0 |          |      655 | 0209 08:24:32.080 |        0 |
robo_a3.11 |      0 |          |       0 |          |        0 |                   |        1 | 0209 08:22:25.120
robo_a2.12 |      0 |          |       0 |          |      630 | 0209 08:24:31.761 |        0 |
robo_a4.13 |      0 |          |       0 |          |        0 |                   |        1 | 0209 08:22:25.120
robo_a1.14 |      0 |          |       0 |          |      647 | 0209 08:24:23.841 |        0 |
 lee_a1.15 |      0 |          |       0 |          |        1 | 0209 08:22:27.841 |        0 |
...
----

The `user` is the sender of the message.  The `repeat`, `rep time` is the count
and time stamp of the last instance.  The `not sub`, `not time` are for the
not subscribed messages.  The `msg loss`, `loss time` are for the multicast
message loss.  The `ibx loss`, `ibx time` are for the point to point inbox
message loss.

[[show_skew]]
- show skew

Show the system time skew between peers.  There are several messages that
include a time stamp which can be used to estimate the system clock skew between
peers.  This is useful to guard against message replays.  If a peer message
arrives and the time + skew is older than the subscription window, then it is
treated as a repeated message.  When the time is within the subscription window,
then a sequence will be associated with the last message received from peer.
The subscription window rotate time is configurable, described in
<<parameters>> of the config section.  This details of the loss calculation is
described in <<msg_loss>>.

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[11]> show skew
   user    |   lat |    hb   | ref |   ping   |   pong  |        time
-----------+-------+---------+-----+----------+---------+------------------
  lex_a2.1 | 241us |  63.5us |   0 |   33.7us | -32.5us | 0209 08:47:48.395
  lex_a3.2 | 119us |  76.9us |   0 |   31.4us | -7.15us | 0209 08:47:48.395
  lex_a4.3 | 157us |   236us |   0 |   32.7us | -15.1us | 0209 08:47:48.395
   edo_a.5 | 302us |  -483us |   4 | -0.161us | -26.1us | 0209 08:47:48.395
  robo_a.6 | 291us | -1.09ms |   4 |  0.154us | -1.41ms | 0209 08:47:48.397
  edo_a4.7 | 521us |   282us |   4 |   31.6us |  -131us | 0209 08:47:48.395
  edo_a3.8 | 512us |   250us |   4 |   -5.1us | -14.7us | 0209 08:47:48.395
  edo_a1.9 | 308us |  1.26ms |   4 |  -12.8us |  72.8us | 0209 08:47:48.395
 edo_a2.10 | 452us |  1.02ms |   4 |  -13.2us |  -222us | 0209 08:47:48.395
robo_a3.11 | 528us |   314us |   4 |     28us | -1.44ms | 0209 08:47:48.397
robo_a2.12 | 468us |   477us |   4 |  -3.79us | -1.47ms | 0209 08:47:48.397
robo_a4.13 | 633us |   571us |   4 |   -8.7us |  -1.5ms | 0209 08:47:48.397
...
----

The first message a peer will see when connecting is the heartbeat message and
authentication messages.  These have a time attached to them and this is the
first time skew calculation that a peer will have.  The `hb` contains this
value and the `ref` is the uid of the peer that is attached and calculated
the skew.  The `ping` and `pong` values are calculated later when a ping 
pong sequence of messages are exchange.  These are more accurate because there
is a larger sample size as the uptime increases.  The `time` is the last time
a skew was calculated.

[[show_reachable]]
- show reachable

Show which transport links can be used to reach a peer.  This table associates
a connection `fd` with a list of peers that are using it.  If this connection
is lost, then these are peers that may be affected by this event.

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[12]> show reachable
   user    |   path  | fd |     tport
-----------+---------+----+------------
  lex_a2.1 | 0,1,2,3 | 19 | lex_amesh.2
  lex_a3.2 |         |    |
  lex_a4.3 |         |    |
  dex_a.24 |         |    |
  pic_a.29 |         |    |
  lee_a.18 |         |    |
  robo_a.6 |         |    |
   edo_a.5 |         |    |
-----------+---------+----+------------
  lex_a3.2 | 0,1,2,3 | 21 | lex_amesh.3
  lex_a2.1 |         |    |
  lex_a4.3 |         |    |
  dex_a.24 |         |    |
  pic_a.29 |         |    |
  robo_a.6 |         |    |
   edo_a.5 |         |    |
...
----

The `user` is the peer, the `path` is a list of paths used with the connection
`fd`, and the `tport` is the transport that contains the connection.

[[show_tree]]
- show tree [U]

Show the multicast tree for a user or self.  This iterates through the
adjacency tables by cost and shows the which peers will be reached after
each step.  The cost increases until all the peers are exhausted.  If
a `U` argument is present, then the multicast tree starts from that peer
instead of the peer attached to the console.

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[14]> show tree
cost | set | alt |  source  |     tport    |   dest
-----+-----+-----+----------+--------------+--------
1000 |   0 |   0 | lex_a1.* |  lex_amesh.2 |  lex_a2
1000 |   1 |   0 | lex_a1.* |  lex_amesh.3 |  lex_a3
1000 |   2 |   0 | lex_a1.* |  lex_amesh.4 |  lex_a4
1000 |   3 |   0 | lex_a1.* |  lex_amesh.5 |   lex_a
-----+-----+-----+----------+--------------+--------
2000 |   0 |   0 | lex_a.33 |    fo_mesh.7 |   edo_a
2000 |   2 |   0 | lex_a.33 |    fo_mesh.9 |  robo_a
2000 |   1 |   0 | lex_a.33 |    fo_mesh.8 |   lee_a
2000 |   4 |   0 | lex_a.33 |   fo_mesh.11 |   dex_a
2000 |   3 |   0 | lex_a.33 |   fo_mesh.10 |   pic_a
-----+-----+-----+----------+--------------+--------
3000 |   0 |   0 |  edo_a.5 |  edo_amesh.4 |  edo_a4
3000 |   1 |   0 |  edo_a.5 |  edo_amesh.5 |  edo_a3
3000 |   2 |   0 |  edo_a.5 |  edo_amesh.6 |  edo_a1
3000 |   3 |   0 |  edo_a.5 |  edo_amesh.7 |  edo_a2
3000 |   4 |   0 | robo_a.6 | robo_amesh.4 | robo_a3
3000 |   5 |   0 | robo_a.6 | robo_amesh.5 | robo_a2
...
----

The `set` is an index into the table used for the next hop, this is calculated
by transitioning across the transport links.  Since the uids are displayed in
order, the `set` may jump back and forth through the table.  The `alt` counter
is an alternate path counter.  Only the 0 `alt` path is used, but the others
are displayed.

The `source` is the forwarding peer that sends the message, the `tport` is the
transport local to the `source`, and `dest` is the receiver.

[[show_path]]
- show path [P]

Show the transports used to reach a peer for a path.  This is the forwarding
table that is used to send a message from the local peer to other peers.

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[15]> show path
    tport   | cost | path_cost |    dest
------------+------+-----------+----------
lex_amesh.2 | 1000 |      1000 |  lex_a2.1
lex_amesh.3 | 1000 |      1000 |  lex_a3.2
lex_amesh.4 | 1000 |      1000 |  lex_a4.3
lex_amesh.5 | 1000 |      2000 |   edo_a.5
lex_amesh.5 | 1000 |      3000 |  edo_a4.7
lex_amesh.5 | 1000 |      3000 |  edo_a3.8
...
----

The `tport` is used for sending a message to `dest`.  The `cost` is the
first hop cost, the `path_cost` is the total cost through all hops.

[[show_forward]]
- show forward [P]

Show the forwarding table for a message received from each of the peers.
When a message is received from a peer, it may need to be forwarded to
other peers to completely cover the network.  This shows the forwarding tables
for each peer.

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[16]> show forward
  source  |     tport   | cost
----------+-------------+-----
 lex_a1.* | lex_amesh.2 | 1000
          | lex_amesh.3 | 1000
          | lex_amesh.4 | 1000
          | lex_amesh.5 | 1000
----------+-------------+-----
 lex_a2.1 |             |
----------+-------------+-----
 lex_a3.2 |             |
...
----

The `source` is index the forwarding table used, the `tport` is the transport
used to forward the message.

[[show_fds]]
- show fds

Show what each fd is used for.  This iterates the `fd` tables and shows what
each `fd` is doing.

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[17]> show fds
fd | rid |      bs     |      br      |     ms    |     mr     | ac | rq | wq | fl |         type        |      kind     |           name           |           address
---+-----+-------------+--------------+-----------+------------+----+----+----+----+---------------------+---------------+--------------------------+--------------------------
 3 |  -1 |           0 |        15321 |         0 |          0 |    |  0 |  0 |    |              logger |        stdout |                          |
 5 |  -1 |             |              |           |            |    |    |    |    |         timer_queue |         timer |                          |
 7 |  -1 |           0 | 717092458452 |         0 | 1943883309 |    |    |    |    |           ipc_route |           ipc |                  rvd.ipc |
 8 |  -1 |           0 |         4235 |         0 |          0 |    |  0 |  0 |    |              logger |        stderr |                          |
 9 |  -1 |             |              |           |            |    |    |    |    |       console_route |       console |              rvd.console |
10 |  -1 |           0 |     99146804 |         0 |     690776 |    |    |    |    |         session_mgr |       session |              rvd.session |
11 |   0 |           0 |  64848767199 |         0 |  261901166 |    |    |    |    |     transport_route |         tport |          rvd.ipc.tport.0 |
12 |   0 |             |              |           |            | 12 |    |    |    |           rv_listen |     rv_listen |        rvd.ipc.rv.list.0 |            127.0.0.1:7500
13 |  -1 |             |              |           |            |  1 |    |    |    |       telnet_listen | telnet_listen |               telnet.tel |              0.0.0.0:2222
14 |  -1 |         210 |            0 |         1 |          0 |    |    |    |    |        name_connect |    mcast_send |           name.eth0.send |        239.23.22.217:8327
15 |  -1 |        1000 |         1260 |         5 |          6 |    |    |    |    |         name_listen |    mcast_recv |           name.eth0.recv |        239.23.22.217:8327
16 |  -1 |             |              |           |            |    |    |    |    |         name_listen |    ucast_recv |          name.eth0.inbox |          172.18.0.2:33643
17 |   1 |             |              |           |            |    |    |    |    |     transport_route |         tport |    rvd.lex_amesh.tport.1 |
18 |   1 |             |              |           |            |  5 |    |    |    | ev_tcp_tport_listen |    tcp_listen | rvd.lex_amesh.tcp_list.1 |          172.18.0.2:42341
19 |   2 |  9458891878 |     28871168 |  27427393 |     121986 |    |  0 |  0 |    |        ev_tcp_tport |    tcp_accept |  rvd.lex_amesh.tcp_acc.1 | lex_a2.1@172.18.0.3:41708
20 |   2 |           0 |     16338022 |         0 |      50587 |    |    |    |    |     transport_route |         tport |    rvd.lex_amesh.tport.2 |
21 |   3 |  9548489486 |     28505122 |  27617221 |     120205 |    |  0 |  0 |    |        ev_tcp_tport |    tcp_accept |  rvd.lex_amesh.tcp_acc.1 | lex_a3.2@172.18.0.4:44630
...
----

The fields are:

[%autowidth,options="header",grid="cols",stripes="even"]
|=============================================
| Field | Description
| fd | File descriptor
| rid | Transport id that fd belongs to
| bs | Bytes sent
| br | Bytes received
| ms | Messages sent
| mr | Message received
| ac | Listener accept count
| rq | Bytes in the receive queue
| wq | Bytes in the send queue
| fl | Socket flags, R,r,<: reading, W,w,>: writing, +: processing.
| type | What type of fd
| kind | What class of fd
| name | The name associated with fd
| address | The local address
|=============================================

[[show_buffers]]
- show buffers

Show the buffer usage of each connection.  These buffers expand to contain
an entire message, since there is no streaming of large messages.

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[18]> show buffers
fd |   wr  |  wmax |   rd  |  rmax | zref |    send   |    recv   | mall | pall |           name
---+-------+-------+-------+-------+------+-----------+-----------+------+------+------------------------
 3 | 32768 | 32768 | 16384 | 16384 |    0 |         0 |       124 |    0 |    0 |
 8 | 32768 | 32768 | 16384 | 16384 |    0 |         0 |        74 |    0 |    0 |
19 | 32768 | 32768 | 16384 | 16384 |    0 |  27189290 |     67973 |    0 |    0 | rvd.lex_amesh.tcp_acc.1
21 | 32768 | 32768 | 16384 | 16384 |    0 |  27224765 |     66485 |    0 |    0 | rvd.lex_amesh.tcp_acc.1
23 | 32768 | 32768 | 16384 | 16384 |    0 |  30118303 |     68727 |    0 |    0 | rvd.lex_amesh.tcp_acc.1
25 | 32768 | 32768 | 16384 | 16384 |    0 |   5498186 |  38629165 |    0 |    0 | rvd.lex_amesh.tcp_acc.1
...
----

The fields are:

[%autowidth,options="header",grid="cols",stripes="even"]
|=============================================
| Field | Description
| fd | File descriptor
| wr | Write buffer size
| wmax | The largest write buffer used
| rd | Read buffer size
| rmax | The largest read buffer used
| zref | Counter incremented after of zero copy sends
| send | Bytes sent
| recv | Bytes received
| mall | Counter incremented when malloc() is used to make a buffer
| pall | Counter incremented when a buffer is borrowed from the buffer pool
| name | Name associated with fd
|=============================================

[[show_windows]]
- show windows

Show the size and counts of the subject publish and subscribe windows as
well as the size of subscription tables and bloom filters.

Example:

[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[19]> show windows
   tab  | count |   size  | win_size | max_size |     rotate_time   | interval
--------+-------+---------+----------+----------+-------------------+---------
    sub | 22515 | 5534080 |  8388608 |  5534080 | 0208 13:23:11.393 |       10
sub_old |     0 |       0 |          |          | 0208 13:23:01.393 |
    pub |  3737 |  344112 |  4194304 |   344112 | 0208 13:23:11.393 |       10
pub_old |     0 |       0 |          |          | 0208 13:23:01.393 |
  inbox |  2724 |  817824 |          |          | 0209 09:52:42.761 |
  route |   137 |   58848 |          |          |                   |
  bloom |  1135 |   18392 |          |          |                   |
     rv |   102 | 1290420 |          |          |                   |
----

The first two are the subscription and publish windows.  These tables are
rotated to old when they get to `win_size` with at least `interval` seconds.
The `max_size` is the largest size of this window.

The `inbox` entry is a route cache for subjects that have a `_INBOX` prefix.
The `route` entry is a cache for routes, indexed by subject hash.  The `bloom`
entry is the sum of the size of bloom filters for every peer in the network.
The `rv` entry is the subscription table for RV clients attached.

[[show_blooms]]
- show blooms [P]

Show where the bloom filters are used for a path.  The forwarding table has
only one transport entry for each peer, path combination.  If a message is
forwarded on more than one transport, it is because there are multiple peers
that are subscribed across multiple transports for the path.  The receiving side
also filters the messages through the bloom filters by calculating the ports
that are needed for the path to completely cover the network.  There may be
redundant transports that are inactive for each path either because the cost
is more or the path selection prefers one transport over the other.

Example:
[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[20]> show blooms
fd |   dest   |     tport   |                                     bloom                                   |       prefix       | detail | subs | total
---+----------+-------------+-----------------------------------------------------------------------------+--------------------+--------+------+------
 9 |  console |       ipc.0 |                                                                   (console) |                  0 |      0 |    0 |     0
11 |    route |       ipc.0 |                                                                 (all-peers) |                  0 |      0 |    0 |     0
---+----------+-------------+-----------------------------------------------------------------------------+--------------------+--------+------+------
 7 |      ipc | lex_amesh.1 |                                                                       (ipc) | 0x000061DF00C38000 |      0 |   24 |   113
10 |  session | lex_amesh.1 |                                                            (console), (sys) |         0x04000108 |      0 |    7 |    15
17 |    route | lex_amesh.1 |                                                                 (all-peers) |                  0 |      0 |    0 |     0
---+----------+-------------+-----------------------------------------------------------------------------+--------------------+--------+------+------
 7 |      ipc | lex_amesh.2 |                                                                       (ipc) | 0x000061DF00C38000 |      0 |   24 |   113
10 |  session | lex_amesh.2 |                                                            (console), (sys) |         0x04000108 |      0 |    7 |    15
19 | lex_a2.1 | lex_amesh.2 |                                                              (peer), lex_a2 | 0x0000008004000108 |      0 |   84 |    91
20 |    route | lex_amesh.2 |                                                                 (all-peers) |                  0 |      0 |    0 |     0
---+----------+-------------+-----------------------------------------------------------------------------+--------------------+--------+------+------
 7 |      ipc | lex_amesh.3 |                                                                       (ipc) | 0x000061DF00C38000 |      0 |   24 |   113
10 |  session | lex_amesh.3 |                                                            (console), (sys) |         0x04000108 |      0 |    7 |    15
21 | lex_a3.2 | lex_amesh.3 |                                                              (peer), lex_a3 | 0x0000008004000108 |      0 |   98 |   105
22 |    route | lex_amesh.3 |                                                                 (all-peers) |                  0 |      0 |    0 |     0
---+----------+-------------+-----------------------------------------------------------------------------+--------------------+--------+------+------
 7 |      ipc | lex_amesh.4 |                                                                       (ipc) | 0x000061DF00C38000 |      0 |   24 |   113
10 |  session | lex_amesh.4 |                                                            (console), (sys) |         0x04000108 |      0 |    7 |    15
23 | lex_a4.3 | lex_amesh.4 |                                                              (peer), lex_a4 | 0x0000008004000108 |      0 |   89 |    96
24 |    route | lex_amesh.4 |                                                                 (all-peers) |                  0 |      0 |    0 |     0
---+----------+-------------+-----------------------------------------------------------------------------+--------------------+--------+------+------
 7 |      ipc | lex_amesh.5 |                                                                       (ipc) | 0x000061DF00C38000 |      0 |   24 |   113
10 |  session | lex_amesh.5 |                                                            (console), (sys) |         0x04000108 |      0 |    7 |    15
25 | lex_a.33 | lex_amesh.5 | (peer), lex_a, pic_a, edo_a, lee_a4, lee_a3, lee_a1, lee_a2, edo_a4, edo_a2 | 0x000061DF04C38108 |      0 |  482 |   636
   |          |             |      edo_a1, edo_a3, dex_a1, dex_a2, dex_a3, dex_a4, pic_a4, pic_a1, pic_a2 |                    |        |      |
   |          |             |                                                        pic_a3, lee_a, dex_a |                    |        |      |
26 |    route | lex_amesh.5 |                                                                 (all-peers) |                  0 |      0 |    0 |     0
----

Every peer has a bloom filter associated with it.  The `console`, `ipc`, and
`sys` filters are the local bloom filters which are combined into one filter in
another peer.  They are split in the local peer so that the traffic destination
can be split to the separate processing functions.  The `sys` filter only match
the subjects that are used for the system, namely, the `_I.<nonce>.>` subject
and the `_M.>` subject.  The `console` are the subjects subscribed by the
console.  The `ipc` are the subjects subscribed by clients.  The `all-peers`
are the combination of all the peers subscriptions, this is used for receiving
messages.  The individual peer bloom filters are for forwarding messages.

The fields are:

[%autowidth,options="header",grid="cols",stripes="even"]
|=============================================
| Field | Description
| fd | File descriptor for the connection
| dest | Where the message would go
| tport | The transport that is used
| bloom | The bloom filters
| prefix | A bit mask of the prefix match length
| detail | A bit mask of the prefix when a suffix is matched or sharded
| subs | The subscription count, not including the patterns
| total | The subscription count including the patterns
|=============================================

[[show_match]]
- show match S

Show which peer bloom filters match a subject.  If a message was published
with subject `S`, this shows which peer's bloom filter would match it.  This
doesn't match against the local filters.

Example:
[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[33]> show match _7500.RSF.REC.AVP.N
   user
---------
lee_a2.16
----

[[show_graph]]
- show graph

Show the graph description of the network.  This creates a description of the
network by matching the names of the transports with the names that the peers
use.  This doesn't use any network probing, it uses the link state database to
calculate the network connectivity.  The link state database doesn't have
connection IP addresses associated with it, but it does have a link name and
link type.  The name/types are enough to describe the network, but doesn't
show how the links are connected to the host with IP addresses.

Example:
[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[34]> show graph
start lex_a1
node edo_a1 edo_a2 edo_a3 lex_a1 lex_a2 edo_a4 edo_a lex_a3 lex_a4 lee_a1 lee_a2 lee_a3 dex_a1 lee_a4 lee_a dex_a2 dex_a3 dex_a4 dex_a pic_a1 pic_a2 pic_a3 pic_a4 pic_a lex_a
mesh_lex_amesh lex_a1 lex_a2 lex_a3 lex_a4 lex_a
mesh_edo_amesh edo_a edo_a4 edo_a3 edo_a1 edo_a2
mesh_fo_mesh edo_a lee_a dex_a pic_a lex_a
mesh_lee_amesh lee_a1 lee_a2 lee_a4 lee_a lee_a3
mesh_dex_amesh dex_a1 dex_a2 dex_a3 dex_a4 dex_a
mesh_pic_amesh pic_a3 pic_a4 pic_a1 pic_a2 pic_a
----

The `start` is the peer attached to the console.  The `node` is the list of
peers in the network ordered by age.  The following lines have a prefix which
is the type of transport used, which is either `mesh`, `tcp`, or `pgm`.  The
suffix of the type is the name of the transport.  Following the "type_name" are
the peers which are connected using this transport.  If the cost is not the
default of 1000, then there will be a ':' followed by the cost of the
transport.

[[show_cache]]
- show cache

Show the route cache hit and miss statistics.  To reduce the number of bloom
filters and hash tables that a message must flow through to match the subject,
the route for the subject is cached.  This cache needs to be updated when a
subscription operation occurs, so this purges the entries which are affected by
these operations, reducing the cache effectiveness.  When a new subject
published will also cause a miss.  The cache size has a maximum of 256K
entries, and when this is hit, the cache is purged and recreated.

Example:
[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[35]> show cache
         tport        | hit_pct |      hit    |    miss    | max_cnt | max_size
----------------------+---------+-------------+------------+---------+---------
      rvd.ipc.tport.0 |   86.70 | 14600408979 | 2239005394 |   24576 |      130
rvd.lex_amesh.tport.1 |    0.00 |           0 |          0 |       0 |        0
rvd.lex_amesh.tport.2 |   84.16 |  1513720684 |  284704081 |    1536 |      447
rvd.lex_amesh.tport.3 |   84.17 |  1513725449 |  284673772 |    1536 |      453
rvd.lex_amesh.tport.4 |   84.16 |  1513723831 |  284727847 |    1536 |      444
rvd.lex_amesh.tport.5 |   88.06 | 16786195897 | 2275244513 |   24576 |      209
----

Each `tport` has a route cache.  The `hit_pct` is a percentage, hit * 100 /
total.  The `hit` is how many times an entry was present in the cache, a `miss`
is not present.  The `max_cnt` is the maximum number of cache entries that have
occurred since the transport was created.  The `max_size` is the max data size
of the entries, which are fds.  Some of the entries will have zero size, when
there is no route for the subject.

[[show_poll]]
- show poll

Show the latency of poll states, the average time used for processing timers,
read, write, and routing events.

Example:
[source%nowrap]
----
lex_a1.rvd[L0MOCmhQpwX2JqsBjYBypA]@lex_a1[36]> show poll
timer_lat | timer_cnt | read_lat |  read_cnt  |    rd_lo   | route_lat |  route_cnt | write_lat |  write_cnt | wr_poll | wr_hi
----------+-----------+----------+------------+------------+-----------+------------+-----------+------------+---------+------
   2.52us |   5548967 |   4.77us | 4936398767 | 2053110538 |    11.4us | 1434068849 |    15.1us | 2053110184 |       0 |    66
----

In a busy router, the read, route, write operations will process multiple
messages at a time, depending on how many fit inside of a read buffer.  A read
buffer is 16KB and is resized only when a large message requires more memory.
The sum of these is close to the average latency used by the router per
message, even if the time used per message is a fraction of that, since the
messages are processed in batches.

The `read_cnt` is the sum of the counts in the `rd_lo` and `read` states, the
`write_cnt` is the sum of the counts in the `write`, `wr_hi`, `wr_poll` states.
The difference between `rd_lo` and `read` is that the `rd_lo` state occurs after
the read buffer is full or the fd has no more data to read.  The `wr_hi` are
the number of times that the write buffer is full.  The `wr_poll` state is the
number of times that the fd is part of the poll set because there is back
pressure on the connection.

Test Pub Sub
~~~~~~~~~~~~

These commands do pub/sub through the console.  The messages have a format
attached to them, which is an integer value mapped to decoding methods.  If
the format is matched with a decoder, then it is decoded to field/value
pairs and printed.  If a method is not matched, then the value is an opaque
string of bytes and that displayed.

[[test_sub]]
- sub S [F]

Subscribe to subject `S`.  If a file is present, then the publishes are sent to
the file instead of printed to the console.

[[test_unsub]]
- unsub S [F]

Unsubscribe to subject `S`.  If a file is present, then stop the publishes sent
to the file.

[[test_psub]]
- psub W [F]

Subscribe to RV style wildcard `W`.  If a file is present, then the publishes
are sent to the file instead of printed to the console.

[[test_punsub]]
- punsub W [F]

Unsubscribe to RV style wildcard `W`.  If a file is present, then stop the
publishes sent to the file.

[[test_gsub]]
- gsub W [F]

Subscribe to glob style wildcard `W`.  If a file is present, then the publishes
are sent to the file instead of printed to the console.

[[test_gunsub]]
- gunsub W [F]

Unsubscribe to glob style wildcard `W`.  If a file is present, then stop the
publishes sent to the file.

[[test_pub]]
- pub S M

Send a message `M` so subscriptions `S`.

[[test_trace]]
- trace S M

Send a message `M` to subscriptions `S` with the trace flag set, which causes
any of the intermediate hops as well as the final destination to send an ack
reply.

[[test_ack]]
- ack S M

Send a message `M` to subscription `S` with the ack flag set, which causes
the destinations to send an ack reply.

[[test_rpc]]
- rpc S M

Send a message `M` to subscription `S` with a return inbox.

[[test_any]]
- any S M

Randomly choose a subscription match for `S` and forward message `M` to that
endpoint.  This would include both wildcard subscriptions and normal ones.

[[test_cancel]]
- cancel

A `cancel` command stops any console subscription or RPC, such as `ping`.  This
marks the endpoint as canceled, so if results are returned after a `cancel`,
they will be discarded.

[[test_reseed]]
- reseed

This alters the local bloom filter to use a different seed.  Changing the bloom
filter seed will alter the bits in the hash such that collisions occur at
different positions.  If a low rate subscription has a collision with a high
rate subscription, this would cause unnecessary traffic that can be avoided by
altering the bloom filter seed.  This doesn't solve when the 32 bit hashes have
collisions, but these are much less likely than a bloom filter collision.

Mute the Logging
~~~~~~~~~~~~~~~~
[[log_mute]]
- mute

The log messages are normally printed to the console, this mutes them.  The log
is still present, using the link:#show_log:[log] command will show them and the
log file if active, will still be appended.  If messages to the console are
being printed too fast for the terminal to display them, this will
automatically turn on.

[[log_unmute]]
- unmute

This removes the `mute` for printing log messages to the console.

Turn On/Off Debug Logging
~~~~~~~~~~~~~~~~~~~~~~~~~

[[debug_log]]
- debug I

The integer value is either a mask or a list of strings that turn the debug
logging on or off.  When `debug 0` is used, this turns of the debug messages.

[%autowidth,options="header",grid="cols",stripes="even"]
|=============================================
| Name      | Value    | Description
| tcp       | 0x1      | Print the subjects as they are sent or received on a TCP connection
| pgm       | 0x2      | Print the subjects as they are sent or received on a PGM connection
| ibx       | 0x4      | The inbox UDP protocol debugging
| transport | 0x8      | Show the message route forwarding
| user      | 0x10     | User updates debugging, when changes are made to a user state
| link_state| 0x20     | Link state message updates are printed
| peer      | 0x40     | Peer synchronization messages are printed
| auth      | 0x80     | Authentication messages are printed
| session   | 0x100    | System message dispatching, IPC message forwarding
| hb        | 0x200    | Heartbeat and ping messages
| sub       | 0x400    | Subscription starts and stops
| msg_recv  | 0x800    | Print system messages when they are received
| msg_hex   | 0x1000   | Dump the system messages in hex when they are received
| telnet    | 0x2000   | Show the telnet protocol states
| name      | 0x4000   | Display name transport update messages
| repeat    | 0x8000   | Print when the repeated subjects are received
| not_sub   | 0x10000  | Print when not subscribed subjects are received
| loss      | 0x20000  | Print debugging when message loss occurs
| adj       | 0x40000  | Print debugging when the link state Dijkstra algo runs
| conn      | 0x80000  | Show debugging about connections, when establish or dropped or timers expire
| stats     | 0x100000 | Print when forwarding a stats, when have subs to _N.> subjects
| dist      |          | This causes the Dijkstra algo to run once
| kvpub     |          | Turns on debugging when any message is processed
| kvps      |          | Turns on debugging when kv pubsub messages are processed
| rv        |          | Turns on debugging when rv message is processed
|=============================================

The last 4 don't have an integer mask because they use different debug
variables that the others.

Write Events to File
~~~~~~~~~~~~~~~~~~~~

[[write_events]]
- wevents F

Dumps the current events to a log file for examining later.  Useful when a
networking problem occurs and is hard to reproduce.

Stop the Server
~~~~~~~~~~~~~~~

[[stop_die]]
- die [I]

Exit the process without shutting down existing connections and sending bye
messages to the network.

[[stop_quit]]
- quit/exit

Normal shutdown.  Existing connections will stop reading new messages send bye
messages to connected peers and flush the data in the write queues.

